import pyodbc
import pandas as pd
import numpy as np
from faker import Faker
import random
# datos para cuando el cliente es una persona natural y paga su propio análisis de santa cruz y sus provincias
# 1. Configuración de Faker y Conexión
fake = Faker(['es_ES'])
#10000 registros santa cruz 0
#8921 registros para lapaz 1
#5331 registros para cochabamba 2
#2613 registros para chuquisaca 3
#potosi 512 registros para potosi 4

#registros = 27377 creados en la bd

def poblar_tabla_cliente():

    try:
        conn_str = (
        'DRIVER={ODBC Driver 17 for SQL Server};'
        'SERVER=localhost\SQLEXPRESS;'
        'DATABASE=LabX2;'
        'Trusted_Connection=yes;'
        )
        con = pyodbc.connect(conn_str)
        cursor = con.cursor()

    except Exception as e:
        print(f"Error al conectar a la base de datos: {e}")
        return
    
    vueltas = 5
    valor_tope = 1
    edad  = list(range(18, 90))
    for k in range(vueltas):      
        cantidad_registros_actual = 0
        provincias = []
        pesos = []
        if k == 0:
            #Santa Cruz
            cantidad_registros_actual = 10000
            provincias = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
            pesos = [0.65, 0.08, 0.03, 0.04, 0.02, 0.02, 0.03, 0.01, 0.01, 0.06, 0.02, 0.005, 0.005, 0.01, 0.01]
        elif k == 1:
            #laPaz
            cantidad_registros_actual = 8921
            provincias = [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]
            pesos = [0.02, 0.005, 0.01, 0.04, 0.02, 0.01, 0.005, 0.05,0.02, 0.005,  0.02, 0.01,  0.03, 0.02, 0.005, 0.015, 0.03, 0.01, 0.65, 0.025 ]
        elif k == 2:
            #Cochabamba
            cantidad_registros_actual = 5331
            provincias = [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]
            pesos = [0.01, 0.005, 0.02, 0.005, 0.02, 0.05, 0.60,  0.06, 0.03,  0.02, 0.01, 0.01,  0.03, 0.11,  0.005, 0.015]
        elif k == 3:
            #chuquisaca
            cantidad_registros_actual = 2613
            provincias = [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
            pesos = [0.02, 0.06, 0.07, 0.03, 0.12,0.55, 0.05, 0.04, 0.04, 0.02]
        elif k == 4:
            #potosi
            cantidad_registros_actual = 512
            provincias = [67, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83]
            pesos = [0.02, 0.08, 0.01, 0.04, 0.10, 0.05, 0.01, 0.005, 0.04, 0.05, 0.06, 0.01, 0.12, 0.06, 0.005, 0.34]

        # 3. Generación de Datos
        pacientes_list = []
        clientes_list = []

        print(f"Generando {cantidad_registros_actual} registros...")

        for i in range(valor_tope , cantidad_registros_actual + (valor_tope - 1) + 1):
            # Datos base
            genero_id = random.choice([1, 2])
            nombre = fake.first_name_male() if genero_id == 1 else fake.first_name_female()
            apellido_p = fake.last_name()
            apellido_m = fake.last_name()
            ci_nit = str(random.randint(4000000, 9000000))
            email = fake.ascii_free_email()
            telefono = str(random.randint(60000000, 79999999))
            
            # Llenamos lista de Clientes
            clientes_list.append({
                'id_cliente': i,
                'nombre': nombre,
                'apellidoP': apellido_p,
                'apellidoM': apellido_m,
                'nit': ci_nit,
                'email': email,
                'telefono': telefono,
                'id_tipo_cliente': 1, # Persona Natural
                'id_convenio': 1      # Particular
            })
            
            # Llenamos lista de Pacientes
            pacientes_list.append({
                'id_paciente': i,
                'nombre': nombre,
                'apellidoP': apellido_p,
                'apellidoM': apellido_m,
                'telefono': telefono,
                'email': email,
                'direccion': f"{fake.street_name()} {fake.building_number()}",
                'ci': ci_nit,
                'id_genero': genero_id,
                'id_provincia': random.choices(provincias, weights=pesos, k=1)[0],
                'edad': random.choice(edad)
            })
        valor_tope = valor_tope + cantidad_registros_actual

        # Convertir a DataFrames
        df_clientes = pd.DataFrame(clientes_list)
        df_pacientes = pd.DataFrame(pacientes_list)

        # 4. Inserción en Base de Datos
        try:
            print("Insertando Clientes...")
            cursor.executemany("""
                INSERT INTO cliente (id_cliente, nombre, apellidoP, apellidoM, nit, email, telefono, id_tipo_cliente, id_convenio)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""", [tuple(x) for x in df_clientes.values])
            
            print("Insertando Pacientes...")
            cursor.executemany("""
                INSERT INTO paciente (id_paciente, nombre, apellidoP, apellidoM, telefono, email, direccion, ci, id_genero, id_provincia, edad)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", [tuple(x) for x in df_pacientes.values])
            
            con.commit()
            print(f"¡Éxito! Se han insertado {cantidad_registros_actual} personas que son Clientes y Pacientes a la vez.")

        except Exception as e:
            print(f"Error durante la inserción: {e}")
    con.close()
    print("Conexión cerrada proceso finalizado")


if __name__ == "__main__":
    poblar_tabla_cliente()

2----
import pyodbc
import random
from datetime import datetime, timedelta

def poblar_movimiento_total():
    conn_str = ('DRIVER={ODBC Driver 17 for SQL Server};'
                'SERVER=localhost\\SQLEXPRESS;'
                'DATABASE=LabX2;'
                'Trusted_Connection=yes;')
    con = pyodbc.connect(conn_str)
    cursor = con.cursor()

    # 1. Cargar Requisitos de Muestra (Diccionario: id_examen -> id_tipo_muestra)
    cursor.execute("SELECT id_examen, id_tipo_muestra FROM examen_requisito_muestra")
    # Creamos un mapa para saber qué tipo de muestra necesita cada examen
    mapa_requisitos = {row[0]: row[1] for row in cursor.fetchall()}

    # 2. Preparación de universos
    ids_pacientes = list(range(1, 27378))
    ids_examenes = list(range(1, 53))
    ids_doctores = list(range(1, 11))
    ids_recepcionistas = list(range(1, 10))

    # TODOS tengan 1 visita + recurrencia
    lista_ids_final = ids_pacientes.copy()
    pacientes_frecuentes = random.sample(ids_pacientes, 8000)
    for _ in range(12623):
        lista_ids_final.append(random.choice(pacientes_frecuentes))

    random.shuffle(lista_ids_final)

    # Contadores globales
    id_detalle_cont = 1
    id_muestra_cont = 1

    print(f"Generando {len(lista_ids_final)} órdenes con lógica de muestras...")

    for i, id_p in enumerate(lista_ids_final, start=1):
        id_orden = i
        fecha_dt = datetime(2024, 1, 1) + timedelta(days=random.randint(0, 730))
        fecha_str = fecha_dt.strftime('%Y-%m-%d')
        
        # A. Crear Orden
        cursor.execute("""
            INSERT INTO orden_laboratorio (id_orden_lab, fecha_orden, estado, numero_orden, id_paciente, id_cliente, id_doctor, id_recepcionista)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)""", 
            (id_orden, fecha_str, "Registrado", 10000 + i, id_p, id_p, random.choice(ids_doctores), random.choice(ids_recepcionistas))
        )

        # B. Lógica de Muestras: ¿Qué exámenes pidió y qué muestras generan?
        n_ex = random.choices([1, 2, 3, 4, 5], weights=[0.4, 0.3, 0.2, 0.08, 0.02], k=1)[0]
        examenes_seleccionados = random.sample(ids_examenes, n_ex)

        # Agrupamos exámenes por el tipo de muestra que requieren para no crear tubos de más
        # Ejemplo: Si 2 exámenes piden 'Sangre', se crea 1 sola muestra de sangre.
        muestras_de_esta_orden = {} # Tipo_Muestra -> ID_Muestra_Generado

        for id_ex in examenes_seleccionados:
            tipo_necesario = mapa_requisitos.get(id_ex, 1) # Default 1 si no hay requisito

            if tipo_necesario not in muestras_de_esta_orden:
                # Insertar nueva muestra física
                cod_m = f"M-{id_p}-{id_muestra_cont}"
                cursor.execute("""
                    INSERT INTO muestra (id_muestra, fecha_toma, estado, codigo_muestra, id_tipo_muestra)
                    VALUES (?, ?, ?, ?, ?)""",
                    (id_muestra_cont, fecha_str, "Recolectada", cod_m, tipo_necesario)
                )
                muestras_de_esta_orden[tipo_necesario] = id_muestra_cont
                id_muestra_actual = id_muestra_cont
                id_muestra_cont += 1
            else:
                # Ya existe un tubo para este tipo de muestra en esta orden
                id_muestra_actual = muestras_de_esta_orden[tipo_necesario]

            # C. Crear Detalle de Orden vinculado a la Muestra
            cursor.execute("""
                INSERT INTO detalle_orden_examen (id_detalle_orden_examen, id_orden_lab, id_examen, id_muestra)
                VALUES (?, ?, ?, ?)""",
                (id_detalle_cont, id_orden, id_ex, id_muestra_actual)
            )
            id_detalle_cont += 1

        # Control de transacciones cada 500 órdenes para no saturar
        if i % 500 == 0:
            con.commit()
            print(f"Progreso: {i} órdenes y sus muestras procesadas...")

    con.commit()
    con.close()
    print("--- Proceso finalizado: Órdenes y Muestras sincronizadas ---")

if __name__ == "__main__":
    poblar_movimiento_total()
3--
import pyodbc
from datetime import datetime
import random

def poblar_facturacion_masiva():
    conn_str = (
        'DRIVER={ODBC Driver 17 for SQL Server};'
        'SERVER=localhost\\SQLEXPRESS;'
        'DATABASE=LabX2;'
        'Trusted_Connection=yes;'
    )
    
    try:
        con = pyodbc.connect(conn_str)
        cursor = con.cursor()
    except Exception as e:
        print(f"Error de conexión: {e}")
        return

    print("Iniciando proceso de facturación optimizado...")

    # 1. Obtener órdenes con información de convenio del cliente para calcular descuentos
    cursor.execute("""
        SELECT 
            ol.id_orden_lab, 
            ol.fecha_orden, 
            doe.id_examen,
            c.porcentaje_descuento
        FROM orden_laboratorio ol
        JOIN detalle_orden_examen doe ON ol.id_orden_lab = doe.id_orden_lab
        JOIN cliente cl ON ol.id_cliente = cl.id_cliente
        JOIN convenio c ON cl.id_convenio = c.id_convenio
    """)
    filas = cursor.fetchall()

    # Estructura para agrupar detalles por factura
    ordenes_procesadas = {}
    
    # 2. Agrupación y cálculo de precios
    for id_orden, fecha, id_ex, pct_descuento in filas:
        # Buscamos el precio del examen vigente a la fecha de la orden
        cursor.execute("""
            SELECT precio 
            FROM examen_precio 
            WHERE id_examen = ? AND ? BETWEEN fecha_inicio AND ISNULL(fecha_fin, '2099-12-31')
        """, (id_ex, fecha))
        
        res_precio = cursor.fetchone()
        precio_v = float(res_precio[0]) if res_precio else 50.0 # Precio base si no encuentra

        if id_orden not in ordenes_procesadas:
            ordenes_procesadas[id_orden] = {
                'fecha': fecha,
                'detalles': [],
                'subtotal_acumulado': 0.0,
                'descuento_acumulado': 0.0,
                'pct_conv': float(pct_descuento) / 100
            }
        
        # Cálculo por línea (examen)
        monto_descuento_linea = precio_v * ordenes_procesadas[id_orden]['pct_conv']
        subtotal_linea = precio_v - monto_descuento_linea
        
        # Guardamos id_ex para el nuevo detalle_factura
        ordenes_procesadas[id_orden]['detalles'].append((precio_v, monto_descuento_linea, subtotal_linea, id_ex))
        
        # Acumuladores de la cabecera
        ordenes_procesadas[id_orden]['subtotal_acumulado'] += precio_v
        ordenes_procesadas[id_orden]['descuento_acumulado'] += monto_descuento_linea

    # 3. Inserción masiva
    id_factura_cont = 1
    id_det_fac_cont = 1
    facturas_batch = []
    detalles_f_batch = []

    estados = [1, 2, 3] # 1: Pagado, 2: Pendiente, 3: Anulado
    pesos_est = [0.85, 0.10, 0.05]
    metodos_pago = [1, 2, 3, 4] # Efectivo, QR, Tarjeta, Transferencia

    for id_orden, data in ordenes_procesadas.items():
        sub_total = data['subtotal_acumulado']
        tot_desc = data['descuento_acumulado']
        total_final = sub_total - tot_desc
        
        id_est = random.choices(estados, weights=pesos_est, k=1)[0]
        id_met = random.choice(metodos_pago)
        
        # INSERT FACTURA
        facturas_batch.append((
            id_factura_cont, data['fecha'], sub_total, tot_desc, total_final, id_est, id_orden, id_met
        ))

        for p_u, d_l, s_l, id_ex_fact in data['detalles']:
            # INSERT DETALLE_FACTURA (Ahora apunta a id_examen directamente)
            detalles_f_batch.append((
                id_det_fac_cont, p_u, d_l, s_l, id_factura_cont, id_ex_fact
            ))
            id_det_fac_cont += 1
        
        id_factura_cont += 1

        # Lotes de 1000 para no saturar la memoria ni la transacción
        if len(facturas_batch) >= 1000:
            cursor.executemany("INSERT INTO factura VALUES (?,?,?,?,?,?,?,?)", facturas_batch)
            cursor.executemany("INSERT INTO detalle_factura VALUES (?,?,?,?,?,?)", detalles_f_batch)
            con.commit()
            facturas_batch, detalles_f_batch = [], []
            print(f"Sincronizadas {id_factura_cont} facturas con sus detalles...")

    # Insertar el resto
    if facturas_batch:
        cursor.executemany("INSERT INTO factura VALUES (?,?,?,?,?,?,?,?)", facturas_batch)
        cursor.executemany("INSERT INTO detalle_factura VALUES (?,?,?,?,?,?)", detalles_f_batch)
        con.commit()

    con.close()
    print(f"--- Proceso finalizado: {id_factura_cont-1} facturas generadas correctamente ---")

if __name__ == "__main__":
    poblar_facturacion_masiva()

4--
import pyodbc
import random
from datetime import datetime, timedelta

def poblar_resultados_analiticos():
    conn_str = ('DRIVER={ODBC Driver 17 for SQL Server};'
                'SERVER=localhost\\SQLEXPRESS;'
                'DATABASE=LabX2;'
                'Trusted_Connection=yes;')
    con = pyodbc.connect(conn_str)
    cursor = con.cursor()

    print("Iniciando generación de resultados médicos...")

    # 1. Preparación de Diccionarios y Listas (FUERA DEL BUCLE)
    cursor.execute("SELECT id_bioquimico FROM bioquimico")
    ids_bioquimicos = [row[0] for row in cursor.fetchall()]

    logica_diagnostica = {
        1: [2, 12, 14], 3: [2, 12], 5: [18], 6: [2, 14], 8: [1, 11],
        9: [1, 11], 10: [16], 11: [16], 12: [15], 13: [4], 15: [5, 13],
        16: [5, 13], 17: [7], 18: [9], 20: [17], 22: [18], 23: [8],
        26: [10], 27: [10], 29: [6], 31: [16], 32: [6], 35: [3],
        36: [3], 37: [3], 39: [19], 40: [1, 19], 48: [20]
    }

    cursor.execute("""
        SELECT p.id_parametro, p.id_examen, vr.id_valor_ref, vr.rango_minimo, vr.rango_maximo, vr.unidad_medida
        FROM parametro p
        JOIN valor_referencia vr ON p.id_parametro = vr.id_parametro
    """)
    mapa_referencias = {}
    for p_id, ex_id, ref_id, v_min, v_max, uni in cursor.fetchall():
        if ex_id not in mapa_referencias:
            mapa_referencias[ex_id] = []
        mapa_referencias[ex_id].append((p_id, ref_id, float(v_min or 0), float(v_max or 100), uni))

    # 2. Obtener órdenes pagadas
    cursor.execute("""
        SELECT doe.id_detalle_orden_examen, doe.id_examen, doe.id_muestra, ol.fecha_orden
        FROM detalle_orden_examen doe
        JOIN orden_laboratorio ol ON doe.id_orden_lab = ol.id_orden_lab
        JOIN factura f ON ol.id_orden_lab = f.id_orden_lab
        WHERE f.id_estado = 1 
    """)
    examenes_a_procesar = cursor.fetchall()

    id_res_cont = 1
    id_det_res_cont = 1
    batch_detalles = [] # Para inserción masiva

    for det_id, ex_id, muestra_id, fecha_o in examenes_a_procesar:
        id_bio = random.choice(ids_bioquimicos)
        
        # Lógica de retraso
        cat = random.choices(['P', 'R', 'E'], weights=[0.75, 0.20, 0.05], k=1)[0]
        retraso = random.randint(1,3) if cat == 'P' else random.randint(4,6) if cat == 'R' else random.randint(7,15)
        fecha_res = fecha_o + timedelta(days=retraso)

        # A. Insertar Cabecera de Resultado
        cursor.execute("""
            INSERT INTO resultado (id_resultado, fecha, id_bioquimico, id_detalle_orden_examen)
            VALUES (?, ?, ?, ?)""",
            (id_res_cont, fecha_res.strftime('%Y-%m-%d'), id_bio, det_id)
        )
        # Nota: He quitado id_muestra del INSERT porque quedamos en que ya no va ahí

        # B. Generar Detalles
        fuera_de_rango = False
        if ex_id in mapa_referencias:
            for p_id, ref_id, v_min, v_max, unidad in mapa_referencias[ex_id]:
                es_sano = random.random() > 0.2
                if es_sano:
                    valor = random.uniform(v_min, v_max)
                else:
                    fuera_de_rango = True
                    valor = v_max + random.uniform(1, 15) if random.random() > 0.5 else max(0, v_min - random.uniform(1, 5))

                batch_detalles.append((id_det_res_cont, round(valor, 2), unidad, p_id, ref_id, id_res_cont))
                id_det_res_cont += 1

        # C. Insertar Hallazgo si aplica
        if fuera_de_rango and ex_id in logica_diagnostica:
            asociadas = logica_diagnostica[ex_id]
            num = random.randint(1, min(2, len(asociadas)))
            elegidas = random.sample(asociadas, num)
            for enf_id in elegidas:
                cursor.execute("INSERT INTO hallazgo_diagnostico VALUES (?, ?, ?)", 
                               ("Hallazgos compatibles con cuadro clínico.", enf_id, id_res_cont))

        # Control de inserción masiva para detalles
        if len(batch_detalles) >= 1000:
            cursor.executemany("INSERT INTO detalle_resultado VALUES (?, ?, ?, ?, ?, ?)", batch_detalles)
            con.commit()
            batch_detalles = []

        id_res_cont += 1
        if id_res_cont % 500 == 0:
            print(f"Sincronizados {id_res_cont} informes médicos...")

    # Insertar remanentes
    if batch_detalles:
        cursor.executemany("INSERT INTO detalle_resultado VALUES (?, ?, ?, ?, ?, ?)", batch_detalles)
    
    con.commit()
    con.close()
    print("--- LabX2: Resultados y Diagnósticos finalizados con éxito ---")

if __name__ == "__main__":
    poblar_resultados_analiticos()